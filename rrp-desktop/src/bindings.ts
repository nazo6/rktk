
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async connect(name: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("connect", { name }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async disconnect() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("disconnect") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSerialPorts() : Promise<Result<SerialPortInfoType[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_serial_ports") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getKeyboardInfo(req: null) : Promise<Result<KeyboardInfo, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_keyboard_info", { req }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getKeymaps() : Promise<Result<KeyActionLoc[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_keymaps") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getLayoutJson() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_layout_json") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setKeymaps(keymaps: KeyActionLoc[]) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_keymaps", { keymaps }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getKeymapConfig(req: null) : Promise<Result<StateConfig, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_keymap_config", { req }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setKeymapConfig(req: StateConfig) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_keymap_config", { req }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/


export const events = __makeEvents__<{
connectionEvent: ConnectionEvent
}>({
connectionEvent: "connection-event"
})

/** user-defined constants **/



/** user-defined types **/

export type ConnectionEvent = boolean
/**
 * Keycode definitions for the HID Usage Tables (HUT) 1.12
 */
export type Key = "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" | "D1" | "D2" | "D3" | "D4" | "D5" | "D6" | "D7" | "D8" | "D9" | "D0" | "Enter" | "Escape" | "Backspace" | "Tab" | "Space" | "Minus" | "Equal" | "LeftBracket" | "RightBracket" | "Backslash" | "NonUsHash" | "Semicolon" | "Quote" | "Grave" | "Comma" | "Dot" | "Slash" | "CapsLock" | "F1" | "F2" | "F3" | "F4" | "F5" | "F6" | "F7" | "F8" | "F9" | "F10" | "F11" | "F12" | "PrintScreen" | "ScrollLock" | "Pause" | "Insert" | "Home" | "PageUp" | "Delete" | "End" | "PageDown" | "Right" | "Left" | "Down" | "Up" | "NumLock" | "KpSlash" | "KpAsterisk" | "KpMinus" | "KpPlus" | "KpEnter" | "Kp1" | "Kp2" | "Kp3" | "Kp4" | "Kp5" | "Kp6" | "Kp7" | "Kp8" | "Kp9" | "Kp0" | "KpDot" | "NonUsBackslash" | "Application" | "KbPower" | "KpEqual" | "F13" | "F14" | "F15" | "F16" | "F17" | "F18" | "F19" | "F20" | "F21" | "F22" | "F23" | "F24" | "Execute" | "Help" | "Menu" | "Select" | "Stop" | "Again" | "Undo" | "Cut" | "Copy" | "Paste" | "Find" | "Mute" | "VolumeUp" | "VolumeDown" | "LockingCapsLock" | "LockingNumLock" | "LockingScrollLock" | "KpComma" | "KpEqualSign" | "International1" | "International2" | "International3" | "International4" | "International5" | "International6" | "International7" | "International8" | "International9" | "Lang1" | "Lang2" | "Lang3" | "Lang4" | "Lang5" | "Lang6" | "Lang7" | "Lang8" | "Lang9" | "AltErase" | "SysReq" | "Cancel" | "Clear" | "Prior" | "Return" | "Separator" | "Out" | "Oper" | "ClearAgain" | "CrSel" | "ExSel" | "Kp00" | "Kp000" | "ThousandsSeparator" | "DecimalSeparator" | "CurrencyUnit" | "CurrencySubUnit" | "KpLeftParen" | "KpRightParen" | "KpLeftBrace" | "KpRightBrace" | "KpTab" | "KpBackspace" | "KpA" | "KpB" | "KpC" | "KpD" | "KpE" | "KpF" | "KpXor" | "KpPower" | "KpPercent" | "KpLess" | "KpGreater" | "KpAmpersand" | "KpDblAmpersand" | "KpVerticalBar" | "KpDblVerticalBar" | "KpColon" | "KpHash" | "KpSpace" | "KpAt" | "KpExclam" | "KpMemStore" | "KpMemRecall" | "KpMemClear" | "KpMemAdd" | "KpMemSubtract" | "KpMemMultiply" | "KpMemDivide" | "KpPlusMinus" | "KpClear" | "KpClearEntry" | "KpBinary" | "KpOctal" | "KpDecimal" | "KpHexadecimal"
/**
 * Defined how key is handled.
 * 
 * - `Normal`: Normal key press.
 * - `Normal2`: Press key with another key.
 * - `TapHold`: If tapped term is too short, treat as `Tap` (first key is used). If tapped term is longer than `TAP_THRESHOLD`, treat as `Hold` (second key is used).
 */
export type KeyAction = "Inherit" | { Normal: KeyCode } | { Normal2: [KeyCode, KeyCode] } | { TapHold: [KeyCode, KeyCode] } | { OneShot: KeyCode } | { TapDance: number }
export type KeyActionLoc = { layer: number; row: number; col: number; key: KeyAction }
/**
 * Represents each key.
 */
export type KeyCode = "None" | { Key: Key } | { Mouse: Mouse } | { Modifier: Modifier } | { Layer: LayerOp } | { Special: Special } | { Media: Media }
export type KeyResolverConfig = { tap_threshold: number; tap_dance_threshold: number; tap_dance: [(TapDanceConfig | null), (TapDanceConfig | null), (TapDanceConfig | null), (TapDanceConfig | null), (TapDanceConfig | null), (TapDanceConfig | null), (TapDanceConfig | null), (TapDanceConfig | null)] }
export type KeyboardInfo = { name: string; rows: number; cols: number; keymap: KeymapInfo }
export type KeymapInfo = { layer_count: number; max_tap_dance_key_count: number; max_tap_dance_repeat_count: number; oneshot_state_size: number; max_resolved_key_count: number }
/**
 * Keycode for layer operations.
 * - `Move`: Move to the layer.
 * - `Toggle`: Move layer only while key is pressed.
 */
export type LayerOp = { Momentary: number } | { Toggle: number }
/**
 * Media key definitions.
 */
export type Media = "Zero" | "Play" | "Pause" | "Record" | "NextTrack" | "PrevTrack" | "Stop" | "RandomPlay" | "Repeat" | "PlayPause" | "Mute" | "VolumeIncrement" | "VolumeDecrement" | "Reserved"
export type Modifier = number
export type Mouse = number
export type MouseConfig = { auto_mouse_layer: number; auto_mouse_duration: number; auto_mouse_threshold: number; scroll_divider_x: number; scroll_divider_y: number }
/**
 * A device-independent implementation of serial port information
 */
export type SerialPortInfo = { 
/**
 * The short name of the serial port
 */
port_name: string; 
/**
 * The hardware device type that exposes this port
 */
port_type: SerialPortType }
export type SerialPortInfoType = SerialPortInfo
/**
 * The physical type of a `SerialPort`
 */
export type SerialPortType = 
/**
 * The serial port is connected via USB
 */
{ UsbPort: UsbPortInfo } | 
/**
 * The serial port is connected via PCI (permanent port)
 */
"PciPort" | 
/**
 * The serial port is connected via Bluetooth
 */
"BluetoothPort" | 
/**
 * It can't be determined how the serial port is connected
 */
"Unknown"
/**
 * Special key definitions.
 * 
 * - `MoScrl`: Enable mouse scroll mode when held.
 */
export type Special = "MoScrl"
export type StateConfig = { mouse: MouseConfig; key_resolver: KeyResolverConfig }
export type TapDanceConfig = { tap: [(KeyCode | null), (KeyCode | null), (KeyCode | null), (KeyCode | null)]; hold: [(KeyCode | null), (KeyCode | null), (KeyCode | null), (KeyCode | null)] }
export type UsbPortInfo = { 
/**
 * Vendor ID
 */
vid: number; 
/**
 * Product ID
 */
pid: number; 
/**
 * Serial number (arbitrary string)
 */
serial_number: string | null; 
/**
 * Manufacturer (arbitrary string)
 */
manufacturer: string | null; 
/**
 * Product name (arbitrary string)
 */
product: string | null }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: T extends null
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
